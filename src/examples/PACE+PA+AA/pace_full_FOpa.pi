
(********   This file has been automatically generated using the tool UKano ********)

(**********)
(* THEORY *)
(**********)


(* public communication channel *)
free c : channel.
free ct : channel.
free cr : channel.

(* constant values *)
free error_mac : bitstring.
free init : bitstring.
free read : bitstring.
free ok : bitstring.
free tagPass : bitstring.
free tagReader : bitstring.
const g : bitstring [data].


(* Generation of a new paramater *)
fun gen(bitstring,bitstring) : bitstring.

(* Diffie-Hellman exponentiation: partial axiomatization
   as defined in the ProVerif 1.92's manual (p. 33) *)
fun exp (bitstring, bitstring) : bitstring.
equation forall x : bitstring, y : bitstring;
  exp(exp(g,x),y) = exp(exp(g,y),x).
equation forall x : bitstring, y : bitstring,
                a : bitstring, b : bitstring;
  exp(exp(gen(a,b),x),y) = exp(exp(gen(a,b),y),x).


fun enc (bitstring, bitstring) : bitstring.
fun dec (bitstring, bitstring) : bitstring.
equation forall x : bitstring, y : bitstring;
  dec(enc(x,y),y) = x.	       

 (* Mac (of pairs) *)
fun mac(bitstring, bitstring) : bitstring.

 (* Signature *)
fun spk(bitstring) : bitstring.
fun sign (bitstring, bitstring) : bitstring.
reduc forall m: bitstring , k:bitstring ;
  getmess(sign(m, k)) = m.
reduc forall m: bitstring , k:bitstring ;
  checksign(sign(m, k), spk(k)) = m.

			       
(*************)
(*  *)


(* == PROTOCOL WITH NONCE VERSIONS == *)
let SYSTEM =
new skP : bitstring;
( !
  new idDGI : bitstring;
  new k_81 : bitstring;
     !
      new sess : bitstring;
      ((
        new s: bitstring;
        new n6: bitstring;
        out(ct, choice[enc(s,k_81),n6]);
        in(ct, x1: bitstring);
        new b1: bitstring;
        new n7: bitstring;
        out(ct, choice[exp(g,b1),n7]);
        in(ct, x2: bitstring);
        new b2: bitstring;
        new n8: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG: bitstring) = gen(exp(g,s),exp(x1,b1)) in
                       exp(newG,b2)  ) in
                catchRealMess
                else n8
            , n8] in
        out(ct, mergeOut);
        in(ct, x3: bitstring);
        new n9: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG: bitstring) = gen(exp(g,s),exp(x1,b1)) in
                    let (newKey: bitstring) = exp(x2,b2) in
                    if (mac((tagReader,exp(newG,b2)),newKey) = x3) then
                       mac((tagPass,x2),newKey)  ) in
                catchRealMess
                else n9
            , n9] in
        out(cr, mergeOut);
        in(ct, x3_82: bitstring);
        new n10: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG: bitstring) = gen(exp(g,s),exp(x1,b1)) in
                    let (newKey: bitstring) = exp(x2,b2) in
                    if (mac((tagReader,exp(newG,b2)),newKey) = x3) then
                    if (dec(x3_82,newKey) = read) then
                       enc((idDGI,sign(idDGI,skP)),newKey)  ) in
                catchRealMess
                else n10
            , n10] in
        out(ct, mergeOut);
        in(ct, x2_83: bitstring);
        new randT: bitstring;
        new n11: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG: bitstring) = gen(exp(g,s),exp(x1,b1)) in
                    let (newKey: bitstring) = exp(x2,b2) in
                    let ((=init,xrandR: bitstring)) = dec(x2_83,newKey) in
                    if (mac((tagReader,exp(newG,b2)),newKey) = x3) then
                    if (dec(x3_82,newKey) = read) then
                       enc(sign((randT,xrandR),skP),newKey)  ) in
                catchRealMess
                else n11
            , n11] in
        out(ct, mergeOut)
      )|(
        in(cr, y1: bitstring);
        new a1: bitstring;
        new n1: bitstring;
        out(cr, choice[exp(g,a1),n1]);
        in(cr, y2: bitstring);
        new a2: bitstring;
        new n2: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG_84: bitstring) = gen(exp(g,dec(y1,k_81)),exp(y2,a1)) in
                       exp(newG_84,a2)  ) in
                catchRealMess
                else n2
            , n2] in
        out(cr, mergeOut);
        in(cr, y3: bitstring);
        new n3: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG_84: bitstring) = gen(exp(g,dec(y1,k_81)),exp(y2,a1)) in
                    let (newKey_85: bitstring) = exp(y3,a2) in
                    if (y3 <> exp(newG_84,a2)) then
                       mac((tagReader,y3),newKey_85)  ) in
                catchRealMess
                else n3
            , n3] in
        out(cr, mergeOut);
        in(cr, y4: bitstring);
        new n4: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG_84: bitstring) = gen(exp(g,dec(y1,k_81)),exp(y2,a1)) in
                    let (newKey_85: bitstring) = exp(y3,a2) in
                    if (y3 <> exp(newG_84,a2)) then
                    if (mac((tagPass,exp(newG_84,a2)),newKey_85) = y4) then
                       enc(read,newKey_85)  ) in
                catchRealMess
                else n4
            , n4] in
        out(cr, mergeOut);
        in(cr, y4_86: bitstring);
        new randR: bitstring;
        new n5: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG_84: bitstring) = gen(exp(g,dec(y1,k_81)),exp(y2,a1)) in
                    let (newKey_85: bitstring) = exp(y3,a2) in
                    let ((ydgi: bitstring,ysign: bitstring)) = dec(y4_86,newKey_85) in
                    if (y3 <> exp(newG_84,a2)) then
                    if (mac((tagPass,exp(newG_84,a2)),newKey_85) = y4) then
                    if (checksign(ysign,spk(skP)) = ydgi) then
                       enc((init,randR),newKey_85)  ) in
                catchRealMess
                else n5
            , n5] in
        out(cr, mergeOut);
        in(cr, y3_87: bitstring);
        out(cr, ok)
      ))
)
 | (!
  new idDGI : bitstring;
  new k_81 : bitstring;
  out(c, idDGI);
     !
      new sess : bitstring;
      ((
        new s: bitstring;
        new n6: bitstring;
        out(ct, choice[enc(s,k_81),n6]);
        in(ct, x1: bitstring);
        new b1: bitstring;
        new n7: bitstring;
        out(ct, choice[exp(g,b1),n7]);
        in(ct, x2: bitstring);
        new b2: bitstring;
        new n8: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG: bitstring) = gen(exp(g,s),exp(x1,b1)) in
                       exp(newG,b2)  ) in
                catchRealMess
                else n8
            , n8] in
        out(ct, mergeOut);
        in(ct, x3: bitstring);
        new n9: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG: bitstring) = gen(exp(g,s),exp(x1,b1)) in
                    let (newKey: bitstring) = exp(x2,b2) in
                    if (mac((tagReader,exp(newG,b2)),newKey) = x3) then
                       mac((tagPass,x2),newKey)  ) in
                catchRealMess
                else n9
            , n9] in
        out(cr, mergeOut);
        in(ct, x3_82: bitstring);
        new n10: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG: bitstring) = gen(exp(g,s),exp(x1,b1)) in
                    let (newKey: bitstring) = exp(x2,b2) in
                    if (mac((tagReader,exp(newG,b2)),newKey) = x3) then
                    if (dec(x3_82,newKey) = read) then
                       enc((idDGI,sign(idDGI,skP)),newKey)  ) in
                catchRealMess
                else n10
            , n10] in
        out(ct, mergeOut);
        in(ct, x2_83: bitstring);
        new randT: bitstring;
        new n11: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG: bitstring) = gen(exp(g,s),exp(x1,b1)) in
                    let (newKey: bitstring) = exp(x2,b2) in
                    let ((=init,xrandR: bitstring)) = dec(x2_83,newKey) in
                    if (mac((tagReader,exp(newG,b2)),newKey) = x3) then
                    if (dec(x3_82,newKey) = read) then
                       enc(sign((randT,xrandR),skP),newKey)  ) in
                catchRealMess
                else n11
            , n11] in
        out(ct, mergeOut)
      )|(
        in(cr, y1: bitstring);
        new a1: bitstring;
        new n1: bitstring;
        out(cr, choice[exp(g,a1),n1]);
        in(cr, y2: bitstring);
        new a2: bitstring;
        new n2: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG_84: bitstring) = gen(exp(g,dec(y1,k_81)),exp(y2,a1)) in
                       exp(newG_84,a2)  ) in
                catchRealMess
                else n2
            , n2] in
        out(cr, mergeOut);
        in(cr, y3: bitstring);
        new n3: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG_84: bitstring) = gen(exp(g,dec(y1,k_81)),exp(y2,a1)) in
                    let (newKey_85: bitstring) = exp(y3,a2) in
                    if (y3 <> exp(newG_84,a2)) then
                       mac((tagReader,y3),newKey_85)  ) in
                catchRealMess
                else n3
            , n3] in
        out(cr, mergeOut);
        in(cr, y4: bitstring);
        new n4: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG_84: bitstring) = gen(exp(g,dec(y1,k_81)),exp(y2,a1)) in
                    let (newKey_85: bitstring) = exp(y3,a2) in
                    if (y3 <> exp(newG_84,a2)) then
                    if (mac((tagPass,exp(newG_84,a2)),newKey_85) = y4) then
                       enc(read,newKey_85)  ) in
                catchRealMess
                else n4
            , n4] in
        out(cr, mergeOut);
        in(cr, y4_86: bitstring);
        new randR: bitstring;
        new n5: bitstring;
        let (mergeOut: bitstring) = 
            choice[ 
                let catchRealMess:bitstring = (
                    let (newG_84: bitstring) = gen(exp(g,dec(y1,k_81)),exp(y2,a1)) in
                    let (newKey_85: bitstring) = exp(y3,a2) in
                    let ((ydgi: bitstring,ysign: bitstring)) = dec(y4_86,newKey_85) in
                    if (y3 <> exp(newG_84,a2)) then
                    if (mac((tagPass,exp(newG_84,a2)),newKey_85) = y4) then
                    if (checksign(ysign,spk(skP)) = ydgi) then
                       enc((init,randR),newKey_85)  ) in
                catchRealMess
                else n5
            , n5] in
        out(cr, mergeOut);
        in(cr, y3_87: bitstring);
        out(cr, ok)
      ))
)
.
process SYSTEM

