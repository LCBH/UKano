(* Lucca Hirschi: test on transformations of protocols *)

(* == THEORY == *)

(* Public communication channel *)
free c : channel.
free i : channel.
free r : channel.
free pbN : bitstring.
(* Public constants *)
free hole : bitstring.
free Fail : bitstring.
free reject : bitstring.
free Sqn : bitstring.

(* UMTS AKA protocol specific mac and bitstring generation functions *)
fun f0(bitstring, bitstring) : bitstring.
fun f1(bitstring, bitstring) : bitstring.
fun f2(bitstring, bitstring) : bitstring.
fun f3(bitstring, bitstring) : bitstring.
fun f4(bitstring, bitstring) : bitstring.
fun f5(bitstring, bitstring) : bitstring.

(* symmetric bitstring encryption function *)
fun senc(bitstring, bitstring, bitstring) : bitstring.
fun sdec(bitstring, bitstring) : bitstring.
equation forall k:bitstring, m:bitstring, rand:bitstring;
  sdec(k, senc(k, rand, m)) = m.

fun eq(bitstring, bitstring): bitstring.
reduc forall x : bitstring; equ(x,x) = x.

(* public bitstring generation function *)
fun pub(bitstring) : bitstring.

(* public bitstring encryption function *)
fun aenc(bitstring, bitstring, bitstring) : bitstring.
reduc forall k : bitstring, m :bitstring, rand : bitstring;
  adec(k, aenc(pub(k), rand, m))= m.


(* PROTOCOLS *)

let R (k:bitstring, imsi:bitstring, otmsi : bitstring, osqn:bitstring,pbN:bitstring) =   (* MS *)
    new r_ms : bitstring;
    new rand : bitstring;
    new rand2 : bitstring;
    in(r, x:bitstring);
    (* Both conditional and creation of response here *)
    let (xrand:bitstring, xautn:bitstring) = x in 
    let (msg:bitstring, xmac:bitstring) = xautn in
    let	 ak = f5(k, xrand) in
    let xsqn  = sdec(ak, msg) in   (* equation so it's OK *)
    let mac =  f1(k, (xrand, xsqn)) in
    let res = f2(k, xrand) in
    let ck = f3(k, xrand) in
    let ik = f4(k, xrand) in
    (
    let checkEq = eq((mac, osqn), (xmac, xsqn))
    in (
      out(r, choice[res, hole]);
      in(r, xmsg:bitstring)
    ) else (
      out(r, choice[aenc(pbN, r_ms, (Fail, imsi, rand, senc(f0(k, rand), rand2, (Sqn, osqn)))), hole]))).


let I (k:bitstring, imsi:bitstring, otmsi : bitstring, osqn:bitstring,pbN:bitstring) = (* SN *)
    new rand : bitstring;
    new r_sn : bitstring;
    new s : bitstring;
    new rand2 : bitstring;
      let mac = f1(k, (rand, osqn)) in
      let res = f2(k, rand) in
      let ck = f3(k, rand) in
      let ik = f4(k, rand) in
      let ak = f5(k, rand) in
      let autn = (senc(ak, r_sn, osqn), mac) in
      let av = (rand, res, ck, ik, ak) in
      let (m1:bitstring, m2:bitstring, Mres:bitstring) = 
      	  ((rand, autn), senc(ik, rand2, s), res)
    in
      out(i, choice[m1, (hole,(hole,hole))]);
      in(i, xres:bitstring);
      if xres = Mres then
         out(i, choice[m2, hole])
      else
         out(i, choice[reject, reject]).

let System =
(*
  new pvN : bitstring;
  let pbN = pub(pvN) in
out(c, pbN)
*)
  (!
    (new sk : bitstring;
     new imsi : bitstring;
     new otmsi : bitstring; 
     new osqn : bitstring;
      ! ( I(sk,imsi,otmsi,osqn,pbN) 
         |
          R(sk,imsi,otmsi,osqn,pbN
  )))).         

process System