(* Lucca Hirschi: test on transformations of protocols *)

(**********)
(* THEORY *)
(**********)

(* public communication channel *)
free c : channel.
free ct : channel.
free cr : channel.

(* constant values *)
free error_mac : bitstring.
free init : bitstring.
free read : bitstring.
free ok : bitstring.

 (* Encryption (with mac inside) *)
fun enc(bitstring, bitstring) : bitstring.
  reduc forall xm:bitstring, xk:bitstring;
        dec(enc(xm, xk), xk) = xm.
		       (* we check mac using idTest*)
letfun idEnc(m:bitstring, k:bitstring) = enc(dec(m, k), k).

 (* Signature *)
fun spk(bitstring) : bitstring.
fun sign (bitstring, bitstring) : bitstring.
reduc forall m: bitstring , k:bitstring ;
  getmess(sign(m, k)) = m.
reduc forall m: bitstring , k:bitstring ;
  checksign(sign(m, k), spk(k)) = m.

(* Over-approximation of (kt XOR kr): xorBitstring has strictly more equations
-> Valid ? *)
fun xorKey(bitstring, bitstring) : bitstring.
fun projKey1(bitstring) : bitstring
reduc forall k1:bitstring, k2:bitstring;
        projKey1(xorKey(k1, k2)) = k1.
fun projKey2(bitstring) : bitstring
reduc forall k1:bitstring, k2:bitstring;
        projKey2(xorKey(k1, k2)) = k2.

fun trydec (bitstring, bitstring) : bitstring
reduc forall m : bitstring, k:bitstring ; trydec ( enc(m,k) , k) = m
otherwise forall x : bitstring , k : bitstring ; trydec ( x , k) = x .
			       
(****************)
(* ==PROTOCOL== *)
(****************)

(* Passive Authentication *)
let RPA(k2:bitstring, skP:bitstring) =
  out(cr, enc(read, k2));
  in(cr, y4:bitstring);
  let (ydgi:bitstring, ysign:bitstring) = dec(y4, k2) in
  if checksign(ysign, spk(skP)) = ydgi
  then out(cr, ok).

let TPA(k2:bitstring, skP:bitstring, dgi:bitstring) =
    in(ct, x3:bitstring);
    if dec(x3, k2) = read
    then out(ct, enc((dgi, sign(dgi, skP)), k2)).

(* Active Authentication *)
let RAA (k2:bitstring, skP:bitstring, randR:bitstring) =
  out(cr, enc((init, randR), k2));
  in(cr, y3:bitstring);
  let m:bitstring = dec(y3, k2) in
  if checksign(m, spk(skP)) = getmess(m)
  then RPA(k2, skP).

let TAA (k2:bitstring, skP:bitstring, dgi:bitstring, randT:bitstring) =
  in(ct, x2:bitstring);
  let (=init, xrandR:bitstring) = dec(x2,k2) in
  out(ct, enc(sign((randT,xrandR), skP), k2));
  TPA(k2, skP, dgi).

(* BAC Protocol *)
let TB (k:bitstring, skP:bitstring, dgi:bitstring, nt:bitstring, kt:bitstring, randT:bitstring) =
(* T ----[n_t]---> R *)
    out(ct,nt);
(* T <----[{nt,nr,kr}_k]--- R *)
    in(ct,x1:bitstring);
    if idEnc(x1,k) = x1
    then 
(* T ----[{nt,nr,kt}_k]---> R *)         
         let (=nt,xnr:bitstring,xkr:bitstring) = dec(x1, k) in (
         out(ct, enc((nt,xnr,kt), k));
(* HOLE *)
         TAA(xorKey(kt,xkr), skP, dgi, randT))
          else
         out(ct, error_mac)	(* error bitstring in FR *)
    else out(ct, error_mac).    (* error mac in FR *)
      
let RB (k:bitstring, skP:bitstring, nr:bitstring, kr:bitstring, randR:bitstring) =
(* R <----[n_t]--- T *)
    in(cr, y1:bitstring);
(* R ----[{nt,nr,kr}_k]---> T *)
    out(cr, enc((y1,nr,kr), k));
(* R <----[{nt,nr,kt}_k]--- T *)
    in(cr, y2:bitstring);
    let (ynt:bitstring, =nr, ykt:bitstring) = dec(y2, k) in (
      let k2:bitstring = xorKey(ykt, kr) in
(* HOLE *)
      RAA(k, skP, randR)
    ).

(* WHOLE SYSTEM *)
let BAC =
  new skP : bitstring ;
  ! new k:bitstring;
    ! new dgi:bitstring;	(* information stored in passports *)
    new nr:bitstring;
    new kr:bitstring;
    new nt:bitstring;
    new kt:bitstring;
    new randT:bitstring;
    new randR:bitstring;
    (TB(k, skP,dgi,nt,kt,randT) | RB(k, skP, nr, kr, randR)).

process BAC