(* Lucca Hirschi: test on transformations of protocols *)

(* ==THEORY== *)

(* public communication channel *)
free c : channel.
free ct : channel.
free cr : channel.

(* constant values *)
free error_mac : bitstring.
free init : bitstring.
free read : bitstring.
free ok : bitstring.


 (* Encryption (with mac inside) *)
fun enc(bitstring, bitstring) : bitstring.
fun dec(bitstring, bitstring) : bitstring.
equation forall xm:bitstring, xk:bitstring;
        dec(enc(xm, xk), xk) = xm.

		       (* we check mac using idTest*)
letfun idEnc(m:bitstring, k:bitstring) = enc(dec(m, k), k).

 (* Signature *)
fun spk(bitstring) : bitstring.
fun sign (bitstring, bitstring) : bitstring.
reduc forall m: bitstring , k:bitstring ;
  getmess(sign(m, k)) = m.
reduc forall m: bitstring , k:bitstring ;
  checksign(sign(m, k), spk(k)) = m.

(* Over-approximation of (kt XOR kr): xorKey has strictly more equations
-> Valid ? *)
fun xorKey(bitstring, bitstring) : bitstring.
(*  TEST sans les Ã©quations, todo ici  *)
fun projBitstring1(bitstring) : bitstring
reduc forall k1:bitstring, k2:bitstring;
        projBitstring1(xorKey(k1, k2)) = k1.
fun projBitstring2(bitstring) : bitstring
reduc forall k1:bitstring, k2:bitstring;
        projBitstring2(xorKey(k1, k2)) = k2.
(*</ici>*)

(* ==PROTOCOL== *)

(* BAC Protocol *)
let TB (k:bitstring, skP:bitstring, dgi:bitstring,nt:bitstring,kt:bitstring,randT:bitstring) =
(* T ----[n_t]---> R *)
    out(ct,nt);
(* T <----[{nt,nr,kr}_k]--- R *)
    in(ct,x1:bitstring);
    if idEnc(x1,k) = x1
    then 
(* T ----[{nt,nr,kt}_k]---> R *)         
         let (xnr:bitstring,=nt,xkr:bitstring) = dec(x1, k) in (
         out(ct, enc((nt,xnr,kt), k))
(* HOLE *)
         ) else
         out(ct, error_mac)	(* error bitstring in FR *)
    else out(ct, error_mac).    (* error mac in FR *)
      
let RB (k:bitstring, skP:bitstring,nr:bitstring,kr:bitstring,randR:bitstring) =
(* R <----[n_t]--- T *)
    in(cr, y1:bitstring);
(* R ----[{nt,nr,kr}_k]---> T *)
    out(cr, enc((nr,y1,kr), k));
(* R <----[{nt,nr,kt}_k]--- T *)
    in(cr, y2:bitstring);
    let (=y1, =nr, ykt:bitstring) = dec(y2, k) in (
(* HOLE *)
     out(cr, enc((init, randR), xorKey(ykt, kr)))    ).

(* WHOLE SYSTEM *)
let BAC =
  new skP : bitstring ;
  ! new k:bitstring;
    ! new dgi:bitstring;	(* information stored in passports *)
    new nt:bitstring;
    new kt:bitstring;
    new randT:bitstring;	
    new randR:bitstring;
    new nr:bitstring;
    new kr:bitstring;
        (TB(k, skP, dgi,nt,kt,randT) | RB(k, skP,nr,kr,randR)).

process BAC