(**********)
(* THEORY *)
(**********)

type nonce.
(* public communication channel *)
free c : channel.
free ct : channel.
free cr : channel.

(* constant values *)
free error_mac : bitstring.
free init : bitstring.
free read : bitstring.
free ok : bitstring.
const g : bitstring [data].
free hole : bitstring.


(* Diffie-Hellman exponentiation *)
fun exp (bitstring, bitstring) : bitstring.
equation forall x : bitstring, y : bitstring;
  exp(exp(g,x),y) = exp(exp(g,y),x).
(* we do not consider all equations of DH expo. but follows Proverif's manual
  (at least it should work) *)

(* Generation of a new paramater *)
fun gen(bitstring,bitstring) : bitstring.

 (* Symmetric Encryption *)
(* If dec defined through a reduction rule -> ATTACK on UK
fun enc(bitstring, bitstring) : bitstring.
  reduc forall xm:bitstring, xk:bitstring;
        dec(enc(xm, xk), xk) = xm.
*)
fun enc (bitstring, bitstring) : bitstring.
fun dec (bitstring, bitstring) : bitstring.
equation forall x : bitstring, y : bitstring;
  dec(enc(x,y),y) = x.	       

 (* Mac (of pairs) *)
fun mac(bitstring, bitstring) : bitstring.
			       
(*************)
(* PROTOCOLS *)
(*************)

(* PACE Protocol *)
let T (k:bitstring) =
    new s:bitstring;
    new b1:bitstring;
    new b2:bitstring;
(* T ----[{s}_k]---> R *)
    out(ct, choice[enc(s,k), hole]);
(* T <---[exp(g,a1)]--- R *)
    in(ct, x1:bitstring);
(* T ----[exp(g,b1)]---> R *)
    out(ct, choice[exp(g,b1), hole]);
(* T <---[exp(gen(g^s,g^(a1.b1)),a2)]--- R *)  
    in(ct, x2:bitstring);
(* T ----[exp(gen(g^s,g^(a1.b1)),b2)]---> R *)  
    out(ct, choice[exp(gen(exp(g,s),exp(x2,b1)),b2), hole]);
(* T <---[mac(exp(gen(g^s,g^(a1.b1)),b2),newBitstring]--- R *)  
    in(ct, x3:bitstring);
    (* newBitstring = exp(gen(g^s,g^(a1.b1)),a2.b2) *)
    let newBitstring:bitstring = exp(x2,b2) in
    if mac(exp(gen(exp(g,s),exp(x2,b1)),b2), newBitstring) = x3
    then 
(* T ----[mac(exp(gen(g^s,g^(a1.b1)),a2),newBitstring]---> R *)  
    out(cr, choice[mac(x2, newBitstring), hole]).
   
let R (k:bitstring) =
    new a1:bitstring;
    new a2:bitstring;
(* R <---[enc(s,k)]--- T *)
    in(cr, y1:bitstring);
(* R ----[exp(g,a1)]---> T *)
    out(cr, choice[exp(g,a1), hole]);
(* R <---[exp(g,b1)]--- T *)
    in(cr, y2:bitstring);
(* R ----[exp(gen(g^s,g^(a1.b1)),a2)]---> T *)  
    out(cr, choice[exp(gen(exp(g,dec(y1,k)),exp(y2,a1)),a2), hole]);
(* R <---[exp(gen(g^s,g^(a1.b1)),b2)]--- T *)  
    in(cr, y3:bitstring);
    (* newBitstring = exp(gen(g^s,g^(a1.b1)),a2.b2) *)

    if y3<>exp(gen(exp(g,dec(y1,k)),exp(y2,a1)),a2) then (* AJOUTEE CAR COMME CA DANS LA SPEC LOW LEVEL *)

    let newBitstring:bitstring = exp(y3,a2) in
(* R ----[mac(exp(gen(g^s,g^(a1.b1)),b2),newBitstring]---> T *)  
    out(cr, choice[mac(y3,newBitstring), hole]);
(* R <---[mac(exp(gen(g^s,g^(a1.b1)),a2),newBitstring]--- T *)  
    in(cr, y4:bitstring);
    if mac(exp(gen(exp(g,dec(y1,k)),exp(y2,a1)),a2), newBitstring) = y4
    then 
(* R ----[ok]---> T *)  
    out(cr, choice[ok, ok]).

(* WHOLE SYSTEM *)
let PACE =
  ! new k:bitstring;
    ! (T(k) | R(k)).

process PACE