(******************************************************)
(*                                                    *)
(*               BAC+PA+AA                            *)
(*                                                    *)
(******************************************************)

(* ==THEORY== *)

(* public communication channel *)
free c : channel.
free ct : channel.
free cr : channel.

(* constant values *)
free hole : bitstring.
free error_mac : bitstring.
free init : bitstring.
free read : bitstring.
free ok : bitstring.

 (* Encryption (with mac inside) *)
fun enc(bitstring, bitstring) : bitstring.
  reduc forall xm:bitstring, xk:bitstring;
        dec(enc(xm, xk), xk) = xm.
		       (* we check mac using idTest*)
letfun idEnc(m:bitstring, k:bitstring) = enc(dec(m, k), k).

(* Mac function *)
fun mac(bitstring,bitstring):bitstring.
  reduc forall km:bitstring, m:bitstring;
  	checkMac(mac(m,km),km) = m.

(* generate new bitstring from seed from two bitstrings *)
fun hashKey(bitstring, bitstring) : bitstring.


(*  *)


(* == DECLARATIONS OF EVENTS == *)
event Rin_1(bitstring,bitstring,bitstring).
event Rout_1(bitstring,bitstring,bitstring,bitstring).
event Rin_2(bitstring,bitstring,bitstring,bitstring,bitstring).
event Rtest_1(bitstring,bitstring,bitstring,bitstring,bitstring).
event Rout_2(bitstring,bitstring,bitstring,bitstring,bitstring,bitstring).
event Iout_1(bitstring,bitstring,bitstring).
event Iin_1(bitstring,bitstring,bitstring,bitstring).
event Itest_1(bitstring,bitstring,bitstring,bitstring).
event Iout_2(bitstring,bitstring,bitstring,bitstring,bitstring).


(* == DECLARATIONS OF QUERIES == *)
query k:bitstring, n1:bitstring, n2:bitstring,
      m1:bitstring, m2:bitstring;
   (event(Itest_1(k,n1,m1,m2))  ==>
   (event(Iin_1(k,n1,m1,m2))  ==>
   (event(Rout_1(k,n2,m1,m2))  ==>
   (event(Rin_1(k,n2,m1))  ==>
   (event(Iout_1(k,n1,m1))))))).
query k:bitstring, n1:bitstring, n2:bitstring,
      m1:bitstring, m2:bitstring, m3:bitstring;
   (event(Rtest_1(k,n2,m1,m2,m3))  ==>
   (event(Rin_2(k,n2,m1,m2,m3))  ==>
   (event(Iout_2(k,n1,m1,m2,m3))  ==>
   (event(Iin_1(k,n1,m1,m2))  ==>
   (event(Rout_1(k,n2,m1,m2))  ==>
   (event(Rin_1(k,n2,m1))  ==>
   (event(Iout_1(k,n1,m1))))))))).


(* == PROTOCOL WITH EVENTS == *)
let SYSTEM =
new skP : bitstring;
 !
 new dgi : bitstring;
 new kM : bitstring;
 new kE : bitstring;
   !
   new sess : bitstring;
   ((
    new nt: bitstring;
    event Iout_1(dgi,sess,nt);
    out(ct, nt);
    in(ct, x1: bitstring);
    event Iin_1(dgi,sess,nt,x1);
    let ((xe: bitstring,xm_40: bitstring)) = x1 in
    let (=xe) = checkMac(xm_40,kM) in
    (
        let ((xnr: bitstring,=nt,xkr: bitstring)) = dec(xe,kE) in
            event Itest_1(dgi,sess,nt,x1);
            new kt: bitstring;
            event Iout_2(dgi,sess,nt,x1,(enc((nt,xnr,kt),kE),mac(enc((nt,xnr,kt),kE),kM)));
            out(ct, (enc((nt,xnr,kt),kE),mac(enc((nt,xnr,kt),kE),kM)))
        else
            out(ct, error_mac)
    )
    else
        out(ct, error_mac)
   )|(
    in(cr, y1: bitstring);
    event Rin_1(dgi,sess,y1);
    new nr: bitstring;
    new kr: bitstring;
    event Rout_1(dgi,sess,y1,(enc((nr,y1,kr),kE),mac(enc((nr,y1,kr),kE),kM)));
    out(cr, (enc((nr,y1,kr),kE),mac(enc((nr,y1,kr),kE),kM)));
    in(cr, y2: bitstring);
    event Rin_2(dgi,sess,y1,(enc((nr,y1,kr),kE),mac(enc((nr,y1,kr),kE),kM)),y2);
    let ((ye: bitstring,ym: bitstring)) = y2 in
    let (=ye) = checkMac(ym,kM) in
    let ((=y1,=nr,ykt: bitstring)) = dec(ye,kE) in
    event Rtest_1(dgi,sess,y1,(enc((nr,y1,kr),kE),mac(enc((nr,y1,kr),kE),kM)),y2);
    new randR: bitstring;
    event Rout_2(dgi,sess,y1,(enc((nr,y1,kr),kE),mac(enc((nr,y1,kr),kE),kM)),y2,enc((init,randR),hashKey(ykt,kr)));
    out(cr, enc((init,randR),hashKey(ykt,kr)))
   ))
.
process SYSTEM
