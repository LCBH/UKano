(******************************************************)
(*                                                    *)
(*               BAC+PA+AA                            *)
(*                                                    *)
(******************************************************)

(* ==THEORY== *)

(* public communication channel *)
free c : channel.
free ct : channel.
free cr : channel.

(* constant values *)
free hole : bitstring.
free error_mac : bitstring.
free init : bitstring.
free read : bitstring.
free ok : bitstring.

 (* Encryption (with mac inside) *)
fun enc(bitstring, bitstring) : bitstring.
  reduc forall xm:bitstring, xk:bitstring;
        dec(enc(xm, xk), xk) = xm.
		       (* we check mac using idTest*)
letfun idEnc(m:bitstring, k:bitstring) = enc(dec(m, k), k).

(* Mac function *)
fun mac(bitstring,bitstring):bitstring.
  reduc forall km:bitstring, m:bitstring;
  	checkMac(mac(m,km),km) = m.

(* generate new bitstring from seed from two bitstrings *)
fun hashKey(bitstring, bitstring) : bitstring.


(*  *)


(* == PROTOCOL WITH NONCE VERSIONS == *)
let SYSTEM =
new skP : bitstring;
 !
 new dgi : bitstring;
 new kM : bitstring;
 new kE : bitstring;
   !
   new sess : bitstring;
   ((
    new nt: bitstring;
    new n4: bitstring;
    out(ct, choice[nt,n4]);
    in(ct, x1: bitstring);
    (
        new kt: bitstring;
        new n5: bitstring;
        new n6: bitstring;
        let (mergeOut: bitstring) = 
          choice[ 
            let ((xe: bitstring,xm_40: bitstring)) = x1 in
            let (=xe) = checkMac(xm_40,kM) in
            let ((xnr: bitstring,=nt,xkr: bitstring)) = dec(xe,kE) in
               (enc((nt,xnr,kt),kE),mac(enc((nt,xnr,kt),kE),kM))
            else (n5,n6)
            else (n5,n6)
            else (n5,n6)
          , (n5,n6)] in
        out(ct, mergeOut)
    ) | (
        out(ct, error_mac)
    ) | (
        out(ct, error_mac)
    )
   )|(
    in(cr, y1: bitstring);
    new nr: bitstring;
    new kr: bitstring;
    new n1: bitstring;
    new n2: bitstring;
    out(cr, choice[(enc((nr,y1,kr),kE),mac(enc((nr,y1,kr),kE),kM)),(n1,n2)]);
    in(cr, y2: bitstring);
    new randR: bitstring;
    new n3: bitstring;
    let (mergeOut: bitstring) = 
      choice[ 
        let ((ye: bitstring,ym: bitstring)) = y2 in
        let (=ye) = checkMac(ym,kM) in
        let ((=y1,=nr,ykt: bitstring)) = dec(ye,kE) in
           enc((init,randR),hashKey(ykt,kr))
        else n3
        else n3
        else n3
      , (n3,n3)] in
    out(cr, mergeOut)
   ))
.
process SYSTEM

