TODO:
C2:
	- être plus souple sur la classe acceptée: surtout la création de noms après les bangs:
          on rappatrie tout ce n'est pas grave... on veut juste au moins un nom créé juste après le second
          bang
        - ça nous permettra de tester les fichiers qu'o na déjà et check les cannot prove

C1:     - trouver comment récupérer/générer les versions nonces (avec choice?)
        - écrire la transfo...

Parsing dans pitsyntax.ml (compressé)

[ let parse filename = 
    lexbuf.Lexing.lex_curr_p <- { lexbuf.Lexing.lex_curr_p with 
    let ptree =   Pitparser.all Pitlexer.token lexbuf  in
    ptree ]

Type de retour: Pitptree.tdecl list * Pitptree.tprocess * Pitptree.tprocess option

Quand on fait: [let p0, second_p0 = Pitsyntax.parse_file s in]
Les tdecl list sont ajoutés à la théorie 
    - tous les noms sont ajoutés; (Terms.re9cord_id nom parsing_info)
    - toute la théorie équationnelle est instanciée (avec le iter check_one x (c'est moche!!))
    - tout est global dans des ref/Hashtbl etc. définis dans pitsyntax.ml (erf)




## QUERY & EVENTS:
dans pitsyntax.ml: let query_list = ref ([] : (envdecl * tquery list) list)
                   let event_fun_table = Hashtbl.create 7

Exemple de création du symbole de l'event dans pitsyntax.ml l.1510:
  let r = { f_name = name;
	    f_type = tyarg, Param.event_type;
	    f_cat = Eq[];
	    f_initial_cat = Eq[];
	    f_private = true;
	    f_options = 0 }

