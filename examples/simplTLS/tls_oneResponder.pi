(* This protocol comes from Protocols for Authentication and Key Establishment by Colin Boyd,Anish Mathuria *)

(**********)
(* THEORY *)
(**********)

(* public communication channel *)
free c : channel.
free ct : channel.
free cr : channel.
free secret : bitstring [ private ].  (* to remove (testing) *)

(* constant values *)
free error_sig : bitstring.
free ok : bitstring.
fun True() : bitstring.


 (* Hash *)
fun hash(bitstring):bitstring.

 (* Symmetric Encryption *)
fun enc(bitstring, bitstring) : bitstring.
  reduc forall xm:bitstring, xk:bitstring;
        dec(enc(xm, xk), xk) = xm.

 (* Asymmetric Encryption *)
fun pkAE(bitstring) : bitstring.
fun aenc(bitstring, bitstring) : bitstring.
  reduc forall xm:bitstring, xk:bitstring;
        adec(aenc(xm, pkAE(xk)), xk) = xm.

 (* Signature *)
fun pkS(bitstring) : bitstring.
fun sign(bitstring, bitstring) : bitstring.
  reduc forall m:bitstring, u:bitstring;
        verify(sign(m,u), pkS(u)) = True.
  reduc forall m:bitstring, u:bitstring;
        getMess(sign(m,u)) = m [private].

 (* Mac (of pairs) *)
fun mac(bitstring, bitstring) : bitstring.
			       
(*************)
(* PROTOCOLS *)
(*************)

let I (skS_I:bitstring, pkAE_R:bitstring) = 
    new r1:bitstring;
(*  I ---[r1]--> R *)
    out(ct, r1);
(*  I <--[r2]--- R *)
    in(ct, xr2:bitstring);
           new PMK:bitstring;
(*  I ---[c1(=aenc(PMK, pk(R))), s1(=sign(h(r1,r2,c1))), enc(h((r1,r2,c1,s2)), xsenc(=mac((r1,r2),PMK)))]--> R *)
           let c1:bitstring = aenc(PMK, pkAE_R) in
	   let s1:bitstring = sign(hash((r1,xr2,c1)), skS_I) in
 	   let c2:bitstring = enc(hash((r1,xr2,c1,s1)), mac((r1,xr2), PMK)) in
           out(ct, (c1, s1, c2));
(*  I <--[enc(h(r1,r2,c1,s1,xsenc), mac((r1,r2), PMK))]--- R *)
           in(ct, y:bitstring);
	   let yenc = dec(y, mac((r1,xr2), PMK)) in
           if yenc = hash((r1,xr2,s1,c2))
           then out(ct, ok).  (* sanity check here: replace ok by secret and check for secrecy *)
         
   
let R (skAE_R:bitstring, pkS_I:bitstring) = 
(*  R <---[r1]--- I *)
    in(cr, xr1:bitstring);
    new r2:bitstring;
(*  R ---[r2]--> I *)
    out(cr, r2);
(*  R <--[c1(=aenc(PMK, pk(R))), s1(=sign(h(r1,r2,c1))), xsenc(=enc(h((r1,r2,c1,s2)), mac((r1,r2),PMK)))]-- T *)
    in(cr, x:bitstring);
    let (xae:bitstring, xsign:bitstring, xsenc:bitstring) = x in
    let (=True, xPMK:bitstring, =hash((xr1,r2,xae))) = (verify(xsign, pkS_I), adec(xae, skAE_R), getMess(xsign)) in
    if xsenc = enc((xr1,r2,xae,xsign), mac((xr1,r2), xPMK)) 
    then (
(*  R ---[enc(h(r1,r2,c1,s1,xsenc), mac((r1,r2), PMK))]--> I *)
           out(ct, enc(hash((xr1,r2,xae,xsign,xsenc)), mac((xr1,r2), xPMK)))
         )
    else out(cr, error_sig).
    
(* WHOLE SYSTEM *)
let SigG =
new skAE_R:bitstring;
! new skS_I:bitstring;
    ! (I(skS_I, pkAE(skAE_R)) | R (skAE_R, pkS(skS_I))).

query attacker(secret).
process SigG